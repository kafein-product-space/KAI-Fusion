#!/usr/bin/env python3
"""
KAI-Fusion Database Setup Script
================================

Bu script, KAI-Fusion platformu i√ßin veritabanƒ±nƒ± olu≈üturur ve g√ºnceller.
Mevcut tablolarƒ± kontrol eder ve eksik olanlarƒ± olu≈üturur.

Kullanƒ±m:
    python database_setup.py [--force] [--check-only] [--drop-all]

Parametreler:
    --force: Mevcut tablolarƒ± silip yeniden olu≈üturur
    --check-only: Sadece mevcut tablolarƒ± kontrol eder
    --drop-all: T√ºm tablolarƒ± siler ve yeniden olu≈üturur
"""

import asyncio
import sys
import os
import argparse
import logging
from typing import List, Dict, Any
from sqlalchemy import text, inspect
from sqlalchemy.ext.asyncio import create_async_engine, AsyncSession
from sqlalchemy.orm import sessionmaker
from dotenv import load_dotenv

load_dotenv()

# Backend dizinini Python path'ine ekle
sys.path.insert(0, os.path.dirname(os.path.abspath(__file__)))

# Logging konfig√ºrasyonu
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(levelname)s - %(message)s',
    handlers=[
        logging.StreamHandler(sys.stdout),
        logging.FileHandler('database_setup.log', encoding='utf-8')
    ]
)
logger = logging.getLogger(__name__)

# Environment variables
DATABASE_URL = os.getenv("DATABASE_URL")
ASYNC_DATABASE_URL = os.getenv("ASYNC_DATABASE_URL")
CREATE_DATABASE = os.getenv("CREATE_DATABASE", "true").lower() in ("true", "1", "t")

class DatabaseSetup:
    """Veritabanƒ± kurulum ve y√∂netim sƒ±nƒ±fƒ±."""
    
    def __init__(self):
        self.engine = None
        self.session_factory = None
        self.expected_tables = [
            "users",
            "user_credentials", 
            "workflows",
            "workflow_templates",
            "workflow_executions",
            "execution_checkpoints",
            "roles",
            "organization",
            "organization_user",
            "login_method",
            "login_activity",
            "chat_message",
            "variable",
            "memories",
            "node_configurations",
            "node_registry",
            "api_keys",
            "scheduled_jobs",
            "job_executions",
            "document_collections",
            "documents",
            "document_chunks",
            "document_access_logs",
            "document_versions",
            "webhook_endpoints",
            "webhook_events"
        ]
        
    async def initialize(self):
        """Veritabanƒ± baƒülantƒ±sƒ±nƒ± ba≈ülatƒ±r."""
        if not CREATE_DATABASE:
            logger.error("CREATE_DATABASE environment variable is not set to 'true'")
            return False
            
        if not ASYNC_DATABASE_URL:
            logger.error("ASYNC_DATABASE_URL environment variable is not set")
            return False
            
        try:
            # Async engine olu≈ütur
            self.engine = create_async_engine(
                ASYNC_DATABASE_URL,
                echo=False,
                pool_pre_ping=True,
                pool_recycle=3600,
                connect_args={
                    "server_settings": {"application_name": "kai-fusion-setup"},
                    "statement_cache_size": 1000,
                    "prepared_statement_cache_size": 100,
                    "command_timeout": 60,
                }
            )
            
            # Session factory olu≈ütur
            self.session_factory = sessionmaker(
                autocommit=False,
                autoflush=False,
                bind=self.engine,
                class_=AsyncSession,
                expire_on_commit=False
            )
            
            logger.info("‚úÖ Veritabanƒ± baƒülantƒ±sƒ± ba≈üarƒ±yla kuruldu")
            return True
            
        except Exception as e:
            logger.error(f"‚ùå Veritabanƒ± baƒülantƒ±sƒ± kurulamadƒ±: {e}")
            return False
    
    async def check_connection(self) -> bool:
        """Veritabanƒ± baƒülantƒ±sƒ±nƒ± test eder."""
        if not self.engine:
            logger.error("Engine hen√ºz ba≈ülatƒ±lmamƒ±≈ü")
            return False
            
        try:
            async with self.engine.begin() as conn:
                result = await conn.execute(text("SELECT 1 as test"))
                row = result.fetchone()
                if row and row[0] == 1:
                    logger.info("‚úÖ Veritabanƒ± baƒülantƒ±sƒ± ba≈üarƒ±lƒ±")
                    return True
                else:
                    logger.error("‚ùå Veritabanƒ± baƒülantƒ± testi ba≈üarƒ±sƒ±z")
                    return False
        except Exception as e:
            logger.error(f"‚ùå Veritabanƒ± baƒülantƒ± testi hatasƒ±: {e}")
            return False
    
    async def get_existing_tables(self) -> List[str]:
        """Mevcut tablolarƒ± listeler."""
        if not self.engine:
            return []
            
        try:
            async with self.engine.begin() as conn:
                # PostgreSQL i√ßin tablo listesi sorgusu - DISTINCT ile tekrarlarƒ± √∂nle
                result = await conn.execute(text("""
                    SELECT DISTINCT tablename 
                    FROM pg_tables 
                    WHERE schemaname = 'public'
                    ORDER BY tablename
                """))
                tables = [row[0] for row in result.fetchall()]
                
                # Tekrarlanan tablolarƒ± kontrol et
                if len(tables) != len(set(tables)):
                    logger.warning("‚ö†Ô∏è Tekrarlanan tablo isimleri tespit edildi!")
                    logger.warning(f"Ham liste: {tables}")
                    # Tekrarlarƒ± kaldƒ±r
                    tables = list(dict.fromkeys(tables))  # Sƒ±rayƒ± koruyarak tekrarlarƒ± kaldƒ±r
                    logger.info(f"Tekrarlar kaldƒ±rƒ±ldƒ±: {tables}")
                
                logger.info(f"üìã Mevcut tablolar: {', '.join(tables) if tables else 'Hi√ß tablo yok'}")
                return tables
        except Exception as e:
            logger.error(f"‚ùå Tablo listesi alƒ±namadƒ±: {e}")
            return []
    
    async def check_table_structure(self, table_name: str) -> Dict[str, Any]:
        """Belirli bir tablonun yapƒ±sƒ±nƒ± kontrol eder."""
        if not self.engine:
            return {"exists": False, "columns": []}
            
        try:
            async with self.engine.begin() as conn:
                # Tablo var mƒ± kontrol et
                result = await conn.execute(text("""
                    SELECT EXISTS (
                        SELECT FROM information_schema.tables 
                        WHERE table_schema = 'public' 
                        AND table_name = :table_name
                    )
                """), {"table_name": table_name})
                
                exists = result.fetchone()[0]
                
                if not exists:
                    return {"exists": False, "columns": []}
                
                # Tablo s√ºtunlarƒ±nƒ± al
                result = await conn.execute(text("""
                    SELECT column_name, data_type, is_nullable, column_default
                    FROM information_schema.columns 
                    WHERE table_schema = 'public' 
                    AND table_name = :table_name
                    ORDER BY ordinal_position
                """), {"table_name": table_name})
                
                columns = [
                    {
                        "name": row[0],
                        "type": row[1],
                        "nullable": row[2] == "YES",
                        "default": row[3]
                    }
                    for row in result.fetchall()
                ]
                
                return {"exists": True, "columns": columns}
                
        except Exception as e:
            logger.error(f"‚ùå {table_name} tablosu yapƒ±sƒ± kontrol edilemedi: {e}")
            return {"exists": False, "columns": []}
    
    async def create_tables(self, force: bool = False):
        """T√ºm tablolarƒ± olu≈üturur."""
        if not self.engine:
            logger.error("Engine hen√ºz ba≈ülatƒ±lmamƒ±≈ü")
            return False
            
        try:
            # Model importlarƒ±
            from app.models.base import Base
            from app.models import (
                User, UserCredential, Workflow, WorkflowTemplate,
                WorkflowExecution, ExecutionCheckpoint, Role, Organization,
                OrganizationUser, LoginMethod, LoginActivity, ChatMessage,
                Variable, Memory, NodeConfiguration, NodeRegistry,
                ScheduledJob, JobExecution,
                DocumentCollection, Document, DocumentChunk, DocumentAccessLog, DocumentVersion,
                WebhookEndpoint, WebhookEvent
            )
            
            # API Key modelini kontrol et
            try:
                from app.models.api_key import APIKey
                logger.info("‚úÖ API Key modeli bulundu")
            except ImportError:
                logger.warning("‚ö†Ô∏è API Key modeli bulunamadƒ±, atlanƒ±yor")
            
            if force:
                logger.warning("‚ö†Ô∏è FORCE modu: T√ºm tablolar silinecek ve yeniden olu≈üturulacak")
                async with self.engine.begin() as conn:
                    await conn.run_sync(Base.metadata.drop_all)
                logger.info("üóëÔ∏è T√ºm tablolar silindi")
            
            # Tablolarƒ± olu≈ütur
            async with self.engine.begin() as conn:
                await conn.run_sync(Base.metadata.create_all)
            
            logger.info("‚úÖ T√ºm tablolar ba≈üarƒ±yla olu≈üturuldu")
            return True
            
        except Exception as e:
            logger.error(f"‚ùå Tablo olu≈üturma hatasƒ±: {e}")
            return False
    
    async def drop_all_tables(self):
        """T√ºm tablolarƒ± siler."""
        if not self.engine:
            logger.error("Engine hen√ºz ba≈ülatƒ±lmamƒ±≈ü")
            return False
            
        try:
            from app.models.base import Base
            
            async with self.engine.begin() as conn:
                await conn.run_sync(Base.metadata.drop_all)
            
            logger.info("üóëÔ∏è T√ºm tablolar silindi")
            return True
            
        except Exception as e:
            logger.error(f"‚ùå Tablo silme hatasƒ±: {e}")
            return False
    
    async def validate_tables(self) -> Dict[str, Any]:
        """T√ºm tablolarƒ± doƒürular."""
        existing_tables = await self.get_existing_tables()
        
        validation_result = {
            "total_expected": len(self.expected_tables),
            "total_existing": len(existing_tables),
            "missing_tables": [],
            "existing_tables": existing_tables,
            "table_details": {}
        }
        
        # Eksik tablolarƒ± bul
        for table in self.expected_tables:
            if table not in existing_tables:
                validation_result["missing_tables"].append(table)
            else:
                # Tablo yapƒ±sƒ±nƒ± kontrol et
                structure = await self.check_table_structure(table)
                validation_result["table_details"][table] = structure
        
        return validation_result
    
    async def setup_database(self, force: bool = False, check_only: bool = False, drop_all: bool = False):
        """Ana veritabanƒ± kurulum fonksiyonu."""
        logger.info("üöÄ KAI-Fusion Veritabanƒ± Kurulum Scripti Ba≈ülatƒ±lƒ±yor...")
        
        # Ba≈ülatma
        if not await self.initialize():
            return False
        
        # Baƒülantƒ± testi
        if not await self.check_connection():
            return False
        
        # Sadece kontrol modu
        if check_only:
            logger.info("üîç Sadece kontrol modu - tablolar olu≈üturulmayacak")
            validation = await self.validate_tables()
            self._print_validation_results(validation)
            return True
        
        # T√ºm tablolarƒ± sil
        if drop_all:
            logger.warning("‚ö†Ô∏è DROP_ALL modu: T√ºm tablolar silinecek!")
            if not await self.drop_all_tables():
                return False
        
        # Mevcut durumu kontrol et
        validation = await self.validate_tables()
        self._print_validation_results(validation)
        
        # Eksik tablolar varsa olu≈ütur
        if validation["missing_tables"] or force:
            if validation["missing_tables"]:
                logger.info(f"üìù Eksik tablolar olu≈üturuluyor: {', '.join(validation['missing_tables'])}")
            
            if not await self.create_tables(force=force):
                return False
            
            # Olu≈üturma sonrasƒ± kontrol
            logger.info("üîç Tablo olu≈üturma sonrasƒ± kontrol...")
            post_validation = await self.validate_tables()
            self._print_validation_results(post_validation)
            
            if post_validation["missing_tables"]:
                logger.error(f"‚ùå Hala eksik tablolar var: {', '.join(post_validation['missing_tables'])}")
                return False
            else:
                logger.info("‚úÖ T√ºm tablolar ba≈üarƒ±yla olu≈üturuldu ve doƒürulandƒ±")
        else:
            logger.info("‚úÖ T√ºm tablolar zaten mevcut")
        
        return True
    
    def _print_validation_results(self, validation: Dict[str, Any]):
        """Doƒürulama sonu√ßlarƒ±nƒ± yazdƒ±rƒ±r."""
        logger.info("=" * 60)
        logger.info("üìä VERƒ∞TABANI DURUM RAPORU")
        logger.info("=" * 60)
        logger.info(f"Beklenen tablo sayƒ±sƒ±: {validation['total_expected']}")
        logger.info(f"Mevcut tablo sayƒ±sƒ±: {validation['total_existing']}")
        
        if validation["missing_tables"]:
            logger.warning(f"‚ùå Eksik tablolar ({len(validation['missing_tables'])}):")
            for table in validation["missing_tables"]:
                logger.warning(f"   - {table}")
        else:
            logger.info("‚úÖ T√ºm beklenen tablolar mevcut")
        
        # Mevcut tablolarƒ± d√ºzenli ≈üekilde g√∂ster
        if validation['existing_tables']:
            logger.info("üìã Mevcut tablolar:")
            # Tablolarƒ± alfabetik sƒ±raya g√∂re grupla
            sorted_tables = sorted(validation['existing_tables'])
            for i, table in enumerate(sorted_tables, 1):
                logger.info(f"   {i:2d}. {table}")
        else:
            logger.info("üìã Mevcut tablo yok")
        
        logger.info("=" * 60)

async def main():
    """Ana fonksiyon."""
    parser = argparse.ArgumentParser(description="KAI-Fusion Veritabanƒ± Kurulum Scripti")
    parser.add_argument("--force", action="store_true", help="Mevcut tablolarƒ± silip yeniden olu≈üturur")
    parser.add_argument("--check-only", action="store_true", help="Sadece mevcut tablolarƒ± kontrol eder")
    parser.add_argument("--drop-all", action="store_true", help="T√ºm tablolarƒ± siler ve yeniden olu≈üturur")
    
    args = parser.parse_args()
    
    # Environment kontrol√º
    if not CREATE_DATABASE:
        logger.error("‚ùå CREATE_DATABASE environment variable 'true' olarak ayarlanmamƒ±≈ü")
        logger.info("üí° √á√∂z√ºm: export CREATE_DATABASE=true")
        sys.exit(1)
    
    if not ASYNC_DATABASE_URL:
        logger.error("‚ùå ASYNC_DATABASE_URL environment variable ayarlanmamƒ±≈ü")
        logger.info("üí° √á√∂z√ºm: export ASYNC_DATABASE_URL='your_database_url'")
        sys.exit(1)
    
    # Database setup ba≈ülat
    db_setup = DatabaseSetup()
    
    try:
        success = await db_setup.setup_database(
            force=args.force,
            check_only=args.check_only,
            drop_all=args.drop_all
        )
        
        if success:
            logger.info("üéâ Veritabanƒ± kurulumu ba≈üarƒ±yla tamamlandƒ±!")
            sys.exit(0)
        else:
            logger.error("‚ùå Veritabanƒ± kurulumu ba≈üarƒ±sƒ±z!")
            sys.exit(1)
            
    except KeyboardInterrupt:
        logger.info("‚èπÔ∏è Kullanƒ±cƒ± tarafƒ±ndan durduruldu")
        sys.exit(1)
    except Exception as e:
        logger.error(f"‚ùå Beklenmeyen hata: {e}")
        sys.exit(1)

if __name__ == "__main__":
    asyncio.run(main()) 